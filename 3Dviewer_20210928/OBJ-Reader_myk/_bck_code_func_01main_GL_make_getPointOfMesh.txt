void voxRead_makeGLdata::func_01main_GL_make_getPointOfMesh_normal(QVector<QOpenGLTriangle3D_vox> &triangles, QString in_voxfilepath)
{
    //■ GL描画用形式への置き換え　通常図形=正方形平面(座標4点）→ GL描画用形式 = 3角形2個(座標6点)　反時計回り座標
    //
    //■ 通常座標 (x, y, z) のまま、設定すると　openGLでは、Y軸と、Z軸が反対に表示されてしまうため
    //  GL座標 (x, -y, -z) として入れなおして計算する
    //
    
    //openGLでの描画単位=1つの三角形ごとの情報作成する。
    //メモリ使用量削減するなら、この処理介さず、 qobj3dviewer.h　setTriangleで使う形式にしてしまった方がいいかもしれない。
    //1三角形ごと個別→頂点情報(v.p1～p3)色情報　は。 2つの三角形で共通→色(colors)、vn(法線=面の向き surfaceStr)。 全三角形で共通→vt(テクスチャ情報)
    triangles.clear();
    QVector<QVector3D> v, vn;
    QVector<QVector2D> vt;

    //voxファイルから座標・面方向・マテリアル情報取得する
    qDebug() << "[DEBUG]voxRead_makeGLdata.cpp-func_01main_GL_make: start func_vox_get_voxGraffic " +  QDateTime::currentDateTime().toString("hh:mm:ss");
    func_vox_get_voxGraffic(in_voxfilepath);
    //zDEBUG_vox_get_voxGraffic_DEBUG01(in_voxfilepath); 元座標が　正方形=閉じた面　で表示OK 全部 (1,1,1) (2,2,2) (10,10,10)などの場合。
    //zDEBUG_vox_get_voxGraffic_DEBUG02(in_voxfilepath);
    qDebug() << "[DEBUG]voxRead_makeGLdata.cpp-func_01main_GL_make: end func_vox_get_voxGraffic " +  QDateTime::currentDateTime().toString("hh:mm:ss");


    //voxファイルからの取得情報を、openGL描画形式のデータに置き換える
    qDebug() << "[DEBUG]voxRead_makeGLdata.cpp-func_01main_GL_make: start makeGLinfo " +  QDateTime::currentDateTime().toString("hh:mm:ss");
    for(int pnum=0; pnum < g_voxXYZVec.count(); pnum++){
        //qDebug() << "[DEBUG]voxRead_makeGLdata.cpp-func_01main_GL_make_getPointOfMesh voxXYZvec=" << QString::number( g_voxXYZVec.at(pnum).x())<< "," <<   QString::number( g_voxXYZVec.at(pnum).y()) << "," <<  QString::number( g_voxXYZVec.at(pnum).z());

        int in_i, in_j, in_k;
        //in_i = 1;
        //in_j = 1;
        //in_k = 1;
        in_i = g_voxXYZVec.at(pnum).x();
        in_j = g_voxXYZVec.at(pnum).y();
        in_k = g_voxXYZVec.at(pnum).z();
        //GLfloat nowOP_x, nowOP_y , nowOP_z;
        float nowOP_x, nowOP_y , nowOP_z;
        float meshsize_x, meshsize_y, meshsize_z;
        meshsize_x = 1;
        meshsize_y = 1;
        meshsize_z = 1;
        nowOP_x = in_i * meshsize_x; //kuroda変更　-0.5 では表示が小さすぎになってしまうための対処
        nowOP_y = in_j * meshsize_y; //kuroda変更　-0.5 では表示が小さすぎになってしまうための対処
        nowOP_z = in_k * meshsize_z; //kuroda変更　-0.5 では表示が小さすぎになってしまうための対処

        //前準備 openGL座標作成 1メッシュ立方体の頂点座標を定義する
        QVector3D vertexA = QVector3D(nowOP_x, nowOP_y, nowOP_z);
        QVector3D vertexB = QVector3D(nowOP_x + meshsize_x, nowOP_y, nowOP_z);
        QVector3D vertexC = QVector3D(nowOP_x + meshsize_x, nowOP_y + meshsize_y, nowOP_z);
        QVector3D vertexD = QVector3D(nowOP_x , nowOP_y + meshsize_y, nowOP_z);
        QVector3D vertexE = QVector3D(nowOP_x, nowOP_y, nowOP_z - meshsize_z);
        QVector3D vertexF = QVector3D(nowOP_x + meshsize_x, nowOP_y, nowOP_z - meshsize_z);
        QVector3D vertexG = QVector3D(nowOP_x + meshsize_x, nowOP_y + meshsize_y, nowOP_z - meshsize_z);
        QVector3D vertexH = QVector3D(nowOP_x , nowOP_y + meshsize_y, nowOP_z - meshsize_z);

        //[DEBUG]
        //    vertexA = QVector3D(0.0, 0.0, 0.0); //Front, Bottom, Left
        //    vertexB = QVector3D(1, 0, 0);
        //    vertexC = QVector3D(1, 1, 0);
        //    vertexD = QVector3D(0, 1, 0);
        //    vertexE = QVector3D(0, 0, -1); //Back,  Bottom, Left
        //    vertexF = QVector3D(1, 0, -1);
        //    vertexG = QVector3D(1, 1, -1);
        //    vertexH = QVector3D(0, 1, -1);

        //前準備(openGL座標作成)  使う対象全部 前後・左右・上下で共通　　後処理trianglesアレイに入れる順番だけ違う。
        vt.append(QVector2D(0.0, 0.0));
        vt.append(QVector2D(1, 0));
        vt.append(QVector2D(1, 1));
        vt.append(QVector2D(0, 1));

        //前準備(openGL座標作成) objファイルのf情報(v, vn, vt の描画上での並び） 使う対象全部 面：前後・左右・上下で共通
        //f 1/1/1 2/2/1 4/3/1
        //f 4/3/1 3/4/1 1/1/1
        //QVector<int> vList;
        //QVector<int> vtList;
        //vList << 1 << 2 << 4 << 4 << 3 << 1;
        //vtList << 1 << 2 << 3 << 3 << 4 << 1;

        //-start- openGL描画用情報作成
        QString in_surfaceStr = "Front";

        //前準備(openGL座標作成)
        QVector<QVector3D> rectVec; //Front など 1平面（四角形の4頂点をopenGL描画用の並びにした座標リスト
        rectVec.clear();
        if(g_voxSurfaceStrList.at(pnum) == "Front"){
            //Front
            rectVec.append(vertexA); //1つ目の三角形
            rectVec.append(vertexB);
            rectVec.append(vertexC);
            rectVec.append(vertexC); //2つ目の三角形
            rectVec.append(vertexD);
            rectVec.append(vertexA);
        }
        if(g_voxSurfaceStrList.at(pnum) == "Back"){
            //Front
            rectVec.append(vertexF); //１つ目の三角形
            rectVec.append(vertexE);
            rectVec.append(vertexH);
            rectVec.append(vertexH); //2つ目の三角形
            rectVec.append(vertexG);
            rectVec.append(vertexF);
        }
        if(g_voxSurfaceStrList.at(pnum) == "Right"){ //Right
            rectVec.append(vertexB); //１つ目の三角形
            rectVec.append(vertexF);
            rectVec.append(vertexG);
            rectVec.append(vertexG); //2つ目の三角形
            rectVec.append(vertexC);
            rectVec.append(vertexB);
        }
        if(g_voxSurfaceStrList.at(pnum) == "Left"){ //Left
            rectVec.append(vertexE); //１つ目の三角形
            rectVec.append(vertexA);
            rectVec.append(vertexD);
            rectVec.append(vertexD); //2つ目の三角形
            rectVec.append(vertexH);
            rectVec.append(vertexE);
        }
        if(g_voxSurfaceStrList.at(pnum) == "Top"){ //Top
            rectVec.append(vertexD); //１つ目の三角形
            rectVec.append(vertexC);
            rectVec.append(vertexG);
            rectVec.append(vertexG); //2つ目の三角形
            rectVec.append(vertexH);
            rectVec.append(vertexD);
        }
        if(g_voxSurfaceStrList.at(pnum) == "Bottom"){ //Bottom
            rectVec.append(vertexE); //１つ目の三角形
            rectVec.append(vertexF);
            rectVec.append(vertexB);
            rectVec.append(vertexB); //2つ目の三角形
            rectVec.append(vertexA);
            rectVec.append(vertexE);
        }

        //前準備(openGL座標作成) objファイルのvn情報　(法線=面の方向)
        //    if(in_surfaceStr == "Front"){  vnStr = "vn 0.0000 0.0000 1.0000" ; }
        //    if(in_surfaceStr == "Back"){   vnStr = "vn 0.0000 0.0000 -1.0000" ; }
        //    if(in_surfaceStr == "Right"){  vnStr = "vn 1.0000 0.0000 0.0000" ; }
        //    if(in_surfaceStr == "Left"){   vnStr = "vn -1.0000 0.0000 0.0000" ; }
        //    if(in_surfaceStr == "Top"){    vnStr = "vn 0.0000 1.0000 0.0000" ; }
        //    if(in_surfaceStr == "Bottom"){ vnStr = "vn 0.0000 -1.0000 0.0000" ; }
        QVector3D vn_now;
        vn_now = QVector3D(0, 0, 1);
        if(g_voxSurfaceStrList.at(pnum) == "Front"){ vn_now = QVector3D(0, 0, 1);  }
        if(g_voxSurfaceStrList.at(pnum) == "Back"){  vn_now = QVector3D(0, 0, -1); }
        if(g_voxSurfaceStrList.at(pnum) == "Right"){ vn_now = QVector3D(1, 0, 0);  }
        if(g_voxSurfaceStrList.at(pnum) == "Left"){  vn_now = QVector3D(-1, 0, 0); }
        if(g_voxSurfaceStrList.at(pnum) == "Top"){   vn_now = QVector3D(0, 1, 0);  }
        if(g_voxSurfaceStrList.at(pnum) == "Bottom"){vn_now = QVector3D(0, -1, 0); }

        for(int shapeCnt=1; shapeCnt<=2; shapeCnt++ ){
            //if(shapeCnt == 1){

            QOpenGLTriangle3D_vox triangle;

            //色設定
            g_GLColors.append(g_voxColors.at(pnum));
            triangle.color = g_voxColors.at(pnum);

            // 1平面(四角形)-1つ目の三角形 頂点情報 (objファイルのvt)
            QVector3D p1, p2, p3;
            if(shapeCnt == 1){
                p1 = rectVec.at(0);
                p2 = rectVec.at(1);
                p3 = rectVec.at(2);
            } else if(shapeCnt == 2){
                p1 = rectVec.at(3);
                p2 = rectVec.at(4);
                p3 = rectVec.at(5);
            }
            triangle.p1 = p1;
            triangle.p2 = p2;
            triangle.p3 = p3;

            QVector2D p1UV, p2UV, p3UV;
            //-start- NG QVector2D(0,0) がなぜか抜けてしまうため、vt.at(3)で落ちてしまう。。
            //if(shapeCnt == 1){
            //    p1UV = vt.at(0);
            //    p2UV = vt.at(1);
            //    p3UV = vt.at(2);
            //} else if (shapeCnt == 2){
            //    p1UV = vt.at(2);
            //    p2UV = vt.at(3);
            //    p3UV = vt.at(0);
            //}
            //-end- NG
            if(shapeCnt == 1){
                p1UV = QVector2D(0.0, 0.0);
                p2UV = QVector2D(1, 0);
                p3UV = QVector2D(1, 1);
            } else if (shapeCnt == 2){
                p1UV = QVector2D(1, 1);
                p2UV = QVector2D(0, 1);
                p3UV = QVector2D(0.0, 0.0);
            }
            triangle.p1UV = p1UV;
            triangle.p2UV = p2UV;
            triangle.p3UV = p3UV;

            triangle.p1Normal = vn_now;
            triangle.p2Normal = vn_now;
            triangle.p3Normal = vn_now;

            triangles.append(triangle);

        }
        //-end- for(int shapeCnt=1; shapeCnt<=2; shapeCnt++ )
    }
    //-end- for(int pnum=0; pnum < g_voxXYZVec.count(); pnum++)
    qDebug() << "[DEBUG]voxRead_makeGLdata.cpp-func_01main_GL_make: end makeGLinfo " +  QDateTime::currentDateTime().toString("hh:mm:ss");

}


